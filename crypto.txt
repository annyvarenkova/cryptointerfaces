// interfaces1.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"
#define _CRT_SECURE_NO_WARNINGS
#pragma warning(disable : 4996)
#include <openssl\aes.h> 
#include <openssl\des.h>
#include <openssl\camellia.h> 
#include <openssl\idea.h> 
#include <openssl\cast.h> 
#include <openssl\evp.h>
#include <openssl\rand.h>
#include <iostream>
#include <string.h>
#include <locale.h>
#include <openssl\rsa.h>
#include <openssl/pem.h>
using namespace std;

struct algorithms
{
	char name_algorithm[10];
	int key_size;
	char mode_algorithm[4];
	const EVP_CIPHER* (*func)();
};

algorithms algo_array[50] = {   {"aes", 128, "ecb", EVP_aes_128_ecb},				{"aes", 128, "cbc", EVP_aes_128_cbc}, 
								{"aes", 128, "ofb", EVP_aes_128_ofb},				{"aes", 128, "cfb", EVP_aes_128_cfb}, 
								{"aes", 192, "ecb", EVP_aes_192_ecb},				{"aes", 192, "cbc", EVP_aes_192_cbc}, 
								{"aes", 192, "ofb", EVP_aes_192_ofb},				{"aes", 192, "cfb", EVP_aes_192_cfb}, 
								{"aes", 256, "ecb", EVP_aes_256_ecb},				{"aes", 256, "cbc", EVP_aes_256_cbc}, 
								{"aes", 256, "ofb", EVP_aes_256_ofb},				{"aes", 256, "cfb", EVP_aes_256_cfb}, 
								{"des", 56, "ecb", EVP_des_ecb},					{"des", 56, "cbc", EVP_des_cbc}, 
								{"des", 56, "ofb", EVP_des_ofb},					{"des", 56, "cfb", EVP_des_cfb}, 
								{"3des", 168, "ecb", EVP_des_ede3_ecb},				{"3des", 168, "cbc", EVP_des_ede3_cbc}, 
								{"3des", 168, "ofb", EVP_des_ede3_ofb},				{"3des", 168, "cfb", EVP_des_ede3_cfb}, 
								{"ede", 128, "ecb", EVP_des_ede_ecb},				{"ede", 256, "cbc", EVP_des_ede_cbc}, 
								{"ede", 256, "ofb", EVP_des_ede_ofb},				{"ede", 256, "cfb", EVP_des_ede_cfb}, 
								{"camellia", 128, "ecb", EVP_camellia_128_ecb},		{"camellia", 128, "cbc", EVP_camellia_128_cbc}, 
								{"camellia", 128, "ofb", EVP_camellia_128_ofb},		{"camellia", 128, "cfb", EVP_camellia_128_cfb},	
								{"camellia", 192, "ecb", EVP_camellia_192_ecb},		{"camellia", 192, "cbc", EVP_camellia_192_cbc}, 
								{"camellia", 192, "ofb", EVP_camellia_192_ofb},		{"camellia", 192, "cfb", EVP_camellia_192_cfb}, 
								{"camellia", 256, "ecb", EVP_camellia_256_ecb},		{"camellia", 256, "cbc", EVP_camellia_256_cbc}, 
								{"camellia", 256, "ofb", EVP_camellia_256_ofb},		{"camellia", 256, "cfb", EVP_camellia_256_cfb}, 
								{"idea", 128, "ecb", EVP_idea_ecb},					{"idea", 128, "cbc", EVP_idea_cbc}, 
								{"idea", 128, "ofb", EVP_idea_ofb},					{"idea", 128, "cfb", EVP_idea_cfb}, 
								{"cast", 128, "ecb", EVP_cast5_ecb},				{"cast", 128, "cbc", EVP_cast5_cbc}, 
								{"cast", 128, "ofb", EVP_cast5_ofb},				{"cast", 128, "cfb", EVP_cast5_cfb}
							};

 const EVP_CIPHER* search_algorithm(char name_algorithm[], int key_size, char* mode_algorithm)
{
	int i;
	for (i = 0; i < sizeof(algo_array); i++) {
		if (!strcmp(algo_array[i].name_algorithm, name_algorithm) && (algo_array[i].key_size == key_size) &&
			!strcmp(algo_array[i].mode_algorithm, mode_algorithm)) {
			return algo_array[i].func();
		}
	}
	return 0;
}

int search_algorithm_id(char* name_algorithm)
{
	if (!strcmp("aes", name_algorithm)) {
		return 1;
	}
	if (!strcmp("des", name_algorithm)) {
		return 2;
	}
	if (!strcmp("3des", name_algorithm)) {
		return 3;
	}
	if (!strcmp("ede", name_algorithm)) {
		return 4;
	}
	if (!strcmp("camellia", name_algorithm)) {
		return 5;
	}
	if (!strcmp("idea", name_algorithm)) {
		return 6;
	}
	if (!strcmp("cast", name_algorithm)) {
		return 7;
	}
	return -1;
}

int search_algorithm_mode(char mode_algorithm[])
{
	if (!strcmp("ecb", mode_algorithm)) {
		return 1;
	}
	if (!strcmp("cbc", mode_algorithm)) {
		return 2;
	}
	if (!strcmp("ofb", mode_algorithm)) {
		return 3;
	}
	if (!strcmp("cfb", mode_algorithm)) {
		return 4;
	}
	return -1;
}

char* search_algorithm_name(int id)
{
	if (id == 1) {
		return "aes";
	}
	if (id == 2) {
		return "des";
	} 
	if (id == 3) {
		return "3des";
	}
	if (id == 4) {
		return "ede";
	}
	if (id == 5) {
		return "camellia";
	}
	if (id == 6) {
		return "idea";
	}
	if (id == 7) {
		return "cast";
	}
	return "error";
}

 int encryption(EVP_PKEY** pub_key, unsigned char *plaintext, int plaintext_len,
	unsigned char **encrypted_key, int *encrypted_key_len, unsigned char *iv,
	unsigned char *ciphertext, char* name_algorithm, int key_size, char* mode_algorithm)
{
	EVP_CIPHER_CTX *ctx;
	int ciphertext_len;
	int len;
	const EVP_CIPHER *cipher;
	if(!(ctx = EVP_CIPHER_CTX_new())) {
		return -1;
	}
	cipher = search_algorithm(name_algorithm, key_size, mode_algorithm);
	if(1 != EVP_SealInit(ctx, cipher, encrypted_key, encrypted_key_len, iv, pub_key, 1)) {
		return -1;
	}
	if(1 != EVP_SealUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {
		return -1;
	}
	ciphertext_len = len;
	if(1 != EVP_SealFinal(ctx, ciphertext + len, &len)) {
		return -1;
	}
	ciphertext_len += len;
	EVP_CIPHER_CTX_free(ctx);

	return ciphertext_len;
}


void read_priv_key(char *fname, EVP_PKEY **key)
{
	BIO *bp;
	bp = BIO_new_file(fname, "r");
	*key = PEM_read_bio_PrivateKey(bp, NULL, NULL, NULL);
	if (*key == NULL) {
		BIO_free_all(bp);
		printf("Reading public key failed");
	}	
	BIO_free_all(bp);
}

void read_pub_key(char *fname, EVP_PKEY **key)
{
	BIO *bp;
	bp = BIO_new_file(fname, "r");
	*key = PEM_read_bio_PUBKEY(bp, NULL, NULL, NULL);
	if (*key == NULL) {
		BIO_free_all(bp);
		printf("Reading public key failed");
	}	
	BIO_free_all(bp);
}

 void gen_keys(int bitCount, char *fname_pubkey, char *fname_privkey) 
 {
	int status = 0;
	RSA *r = NULL;
	BIGNUM *bne = NULL;
	BIO *bp_public = NULL, *bp_private = NULL;

	unsigned long   e = RSA_F4;
	 
	bne = BN_new();
	status = BN_set_word(bne, e);
	if (status != 1) {
		BIO_free_all(bp_public);
		(bp_private);
		RSA_free(r);
		BN_free(bne);
	}
	r = RSA_new();
	status = RSA_generate_key_ex(r, bitCount, bne, NULL);
	if (status != 1) {
		BIO_free_all(bp_public);
		BIO_free_all(bp_private);
		RSA_free(r);
		BN_free(bne);
	}
	bp_public = BIO_new_file(fname_pubkey, "w");
	status = PEM_write_bio_RSA_PUBKEY(bp_public, r);
	if (status != 1) {
		BIO_free_all(bp_public);
		BIO_free_all(bp_private);
		RSA_free(r);
		BN_free(bne);
	}
	bp_private = BIO_new_file(fname_privkey, "w");
	status = PEM_write_bio_RSAPrivateKey(bp_private, r, NULL, NULL, 0, NULL, NULL);
	BIO_free_all(bp_public);
	BIO_free_all(bp_private);
	RSA_free(r);
	BN_free(bne);
}

int _tmain(int argc, _TCHAR* argv[])
{
	OpenSSL_add_all_algorithms();
	printf("Enter name of file to encrypt:\n");
	char data_file_name[30];
	scanf("%s", &data_file_name);
	printf("Enter algorithm of cipher:\n");
	char name_algorithm[10];
	scanf("%s", &name_algorithm);
	printf("Enter size of key:\n");
	int key_size;
	scanf("%i", &key_size);
	printf("Enter size of block:\n");
	int block_size;
	scanf("%i", &block_size);
	printf("Enter mode of cipher:\n");
	char mode_algorithm[4];
	cin >> mode_algorithm;
	int size = key_size / 8 + 1;
	unsigned char* session_key = new unsigned char[size];
	printf("Enter key to encrypt:\n");
	cin >> session_key;
	int session_key_size = size - 1;
	printf("Enter name of file to save encrypted data:\n");
	char encrypted_file_name[30];
	scanf("%s", &encrypted_file_name);
	FILE* input_data = fopen(data_file_name, "r");
	fseek(input_data, 0, SEEK_END);
	int in_data_size = ftell(input_data);
	fseek(input_data, 0, SEEK_SET);
	unsigned char* iv = new unsigned char[size];
	RAND_bytes(iv, size - 1);
	char decrypted_file_name[30];
	strcpy(decrypted_file_name, "3.txt");
	unsigned char* plaintext = new unsigned char[in_data_size];
	fread(plaintext, 1, in_data_size, input_data);
	fclose(input_data);
	unsigned char* ciphertext = new unsigned char[in_data_size + 1000];
	int cipher_len;
	gen_keys(1024, "pubkey1.pem", "privkey1.pem");
	gen_keys(1024, "pubkey2.pem", "privkey2.pem");
	EVP_PKEY* public_key;
	read_pub_key("pubkey1.pem", &public_key);
	int raz = EVP_PKEY_size(public_key);
	cipher_len = encryption(&public_key, plaintext, in_data_size, &session_key, &session_key_size, iv, ciphertext, name_algorithm, key_size, mode_algorithm);
	if (cipher_len == -1) {
		printf("=(");
		return 0;
	}
	printf("OK\n");
	FILE* out_data = fopen("2.txt", "w");
	if (out_data == NULL) {
		printf("File error!\n");
		return -1;
	}
	fprintf(out_data, "%c", (char)size);
	fwrite(iv, 1, size, out_data);
	fwrite(ciphertext, 1, cipher_len, out_data);
	fclose(out_data);
	getchar();
	fclose(input_data);
	fclose(out_data);
	fclose(decrypted_data);
	delete[] session_key;
	delete[] plaintext;
	delete[] ciphertext;
	delete[] iv;
	return 0;
}
